import traceback

from barbequeue.worker.backends.base import BaseWorkerBackend


class WorkerBackend(BaseWorkerBackend):
    # worker types
    PROCESS = 1
    THREAD = 0

    def __init__(self, worker_type=THREAD, *args, **kwargs):
        # Internally, we use conncurrent.future.Future to run and track
        # job executions. We need to keep track of which future maps to which
        # job they were made from, and we use the job_future_mapping dict to do
        # so.
        self.job_future_mapping = {}
        self.worker_type = worker_type
        super(WorkerBackend, self).__init__(*args, **kwargs)

    def schedule_job(self, job):
        """
        schedule a job to the type of workers spawned by self.start_workers.
        
        
        :param job: the job to schedule for running.
        :return: 
        """
        l = _reraise_with_traceback(job.get_lambda_to_execute())

        if job.track_progress:
            future = self.workers.submit(l, self.update_progress)
        else:
            future = self.workers.submit(l)

        # assign the futures to a dict, mapping them to a job
        self.job_future_mapping[future] = job
        # callback for when the future is now!
        future.add_done_callback(self.handle_finished_future)

        return future

    def shutdown(self, wait=True):
        self.workers.shutdown(wait=wait)

    def start_workers(self, num_workers):
        if self.worker_type == self.PROCESS:
            from concurrent.futures import ProcessPoolExecutor
            worker_executor = ProcessPoolExecutor
        elif self.worker_type == self.THREAD:
            from concurrent.futures import ThreadPoolExecutor
            worker_executor = ThreadPoolExecutor
        else:
            raise ValueError(
                "WorkerBackend.worker_type must be one of [WorkerBackend.PROCESS, WorkerBackend.THREAD]"
            )

        pool = worker_executor(max_workers=num_workers)
        return pool

    def handle_finished_future(self, future):
        # get back the job assigned to the future
        job = self.job_future_mapping[future]

        try:
            result = future.result()
        except Exception as e:
            self.report_error(job, e, e.traceback)
            return

        self.report_success(job, result)


def _reraise_with_traceback(f):
    """
    Call the function normally. But if the function raises an error, attach the str(traceback)
    into the function.traceback attribute, then reraise the error.
    Args:
        f: The function to run.

    Returns: A function that wraps f, attaching the traceback if an error occurred.

    """

    def wrap(*args, **kwargs):
        try:
            return f(*args, **kwargs)
        except Exception as e:
            traceback_str = traceback.format_exc()
            e.traceback = traceback_str
            raise e

    return wrap
